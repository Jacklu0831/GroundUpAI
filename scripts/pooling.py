# ---------------------------------------------
# | THIS FILE WAS AUTOGENERATED! DO NOT EDIT! |
# ---------------------------------------------
# edit notebooks/10_pooling.ipynb and run generate_all.py

import sys
sys.path.insert(0, '/'.join(sys.path[0].split('/')[:-1] + ['scripts']))

from convolution import *

class MaxPool(Module):
    def __init__(self, k_s=3, stride=1, pad=0):
        super().__init__()
        self.k_s = k_s
        self.stride = stride
        self.pad = pad

    def fwd(self, inp):
        batch_size, in_c, in_h, in_w = inp.shape
        out_dim = lambda d: (d + 2 * self.pad - self.k_s) // self.stride + 1
        out_c, out_h, out_w = in_c, out_dim(in_h), out_dim(in_w)

        padded = pad_tensor(inp, self.pad, inp.min()) if self.pad > 0 else inp
        out = torch.zeros(batch_size, out_c, out_h, out_w)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i * self.stride, j * self.stride
                in_window = padded[:, :, i_s: i_s+self.k_s, j_s: j_s+self.k_s]
                out[:,:,i,j] = in_window.max(-1)[0].max(-1)[0]
        return out

    def bwd(self, out, inp):
        dL = out.g
        batch_size, out_c, out_h, out_w = dL.shape

        padded = pad_tensor(inp, self.pad, inp.min()) if self.pad > 0 else inp
        dX = torch.zeros_like(padded)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i*stride, j*stride
                inp_w = padded[:, :, i_s:i_s+k_s, j_s:j_s+k_s]
                mask = torch.zeros_like(inp_w)
                for i in range(mask.shape[0]):
                    for j in range(mask.shape[1]):
                        mask[i,j,:,:] = inp_w[i,j,:,:] == inp_w[i,j,:,:].max()
                dX[:, :, i_s:i_s+k_s, j_s:j_s+k_s] += dL[:,:,i,j][...,None,None] * mask
        padded.g = dX

    def __repr__(self, t=''):
        return f"{t+'    '}MaxPool({self.k_s}, {self.stride})"

class AvgPool(Module):
    def __init__(self, k_s=3, stride=1, pad=0):
        super().__init__()
        self.k_s = k_s
        self.stride = stride
        self.pad = pad

    def fwd(self, inp):
        batch_size, in_c, in_h, in_w = inp.shape
        out_dim = lambda d: (d + 2 * self.pad - self.k_s) // self.stride + 1
        out_c, out_h, out_w = in_c, out_dim(in_h), out_dim(in_w)

        padded = pad_tensor(inp, self.pad) if self.pad > 0 else inp
        out = torch.zeros(batch_size, out_c, out_h, out_w)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i * self.stride, j * self.stride
                in_window = padded[:, :, i_s: i_s+self.k_s, j_s: j_s+self.k_s]
                out[:,:,i,j] = torch.mean(in_window, (-1, -2))
        return out

    def bwd(self, out, inp):
        dL = out.g
        batch_size, out_c, out_h, out_w = dL.shape

        padded = pad_tensor(inp, self.pad) if self.pad > 0 else inp
        dX = torch.zeros_like(padded)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i*self.stride, j*self.stride
                dX[:, :, i_s:i_s+self.k_s, j_s:j_s+self.k_s] += dL[:,:,i,j][...,None,None] / (self.k_s ** 2)
        padded.g = dX

    def __repr__(self, t=''):
        return f"{t+'    '}AvgPool({self.k_s}, {self.stride})"

def get_conv_pool_model(data_bunch):
    return Sequential(Reshape((1, 28, 28)),
                      Conv(c_in=1, c_out=4, k_s=5, stride=2, pad=1), # 4, 13, 13
                      AvgPool(k_s=2, pad=0), # 4, 12, 12
                      Conv(c_in=4, c_out=16, stride=2, leak=1.), # 16, 5, 5
                      Flatten(),
                      Linear(400, 64),
                      ReLU(),
                      Linear(64, 10, True))