# ---------------------------------------------
# | THIS FILE WAS AUTOGENERATED! DO NOT EDIT! |
# ---------------------------------------------
# edit notebooks/06_pooling.ipynb and run generate_all.py

import sys
from os.path import join

sys.path.insert(0, '/'.join(sys.path[0].split('/')[:-1] + ['scripts']))
from convolution import *

class MaxPool2d(Module):
    def __init__(self, k_s=3, stride=1, pad=0):
        super().__init__()
        self.k_s = k_s
        self.stride = stride
        self.pad = pad

    def fwd(self, inp):
        batch_size, in_c, in_h, in_w = inp.shape
        out_dim = lambda d: (d + 2 * self.pad - self.k_s) // self.stride + 1
        out_c, out_h, out_w = in_c, out_dim(in_h), out_dim(in_w)

        padded = pad_tensor(inp, self.pad, inp.min()) if self.pad > 0 else inp
        out = torch.zeros(batch_size, out_c, out_h, out_w)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i * self.stride, j * self.stride
                in_window = padded[:, :, i_s: i_s+self.k_s, j_s: j_s+self.k_s]
                out[:,:,i,j] = in_window.max(-1)[0].max(-1)[0]
        return out

    def bwd(self, out, inp):
        dL = out.g
        batch_size, out_c, out_h, out_w = dL.shape

        padded = pad_tensor(inp, self.pad, inp.min()) if self.pad > 0 else inp
        dX = torch.zeros_like(padded)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i*stride, j*stride
                inp_w = padded[:, :, i_s:i_s+k_s, j_s:j_s+k_s]
                mask = torch.zeros_like(inp_w)
                for i in range(mask.shape[0]):
                    for j in range(mask.shape[1]):
                        mask[i,j,:,:] = inp_w[i,j,:,:] == inp_w[i,j,:,:].max()
                dX[:, :, i_s:i_s+k_s, j_s:j_s+k_s] += dL[:,:,i,j][...,None,None] * mask
        padded.g = dX

    def __repr__(self):
        return f'MaxPool2d(kernel_size: {self.k_s}, stride: {self.stride}, pad: {self.pad})'

class AvgPool2d(Module):
    def __init__(self, k_s=3, stride=1, pad=0):
        super().__init__()
        self.k_s = k_s
        self.stride = stride
        self.pad = pad

    def fwd(self, inp):
        batch_size, in_c, in_h, in_w = inp.shape
        out_dim = lambda d: (d + 2 * self.pad - self.k_s) // self.stride + 1
        out_c, out_h, out_w = in_c, out_dim(in_h), out_dim(in_w)

        padded = pad_tensor(inp, self.pad) if self.pad > 0 else inp
        out = torch.zeros(batch_size, out_c, out_h, out_w)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i * self.stride, j * self.stride
                in_window = padded[:, :, i_s: i_s+self.k_s, j_s: j_s+self.k_s]
                out[:,:,i,j] = torch.mean(in_window, (-1, -2))
        return out

    def bwd(self, out, inp):
        dL = out.g
        batch_size, out_c, out_h, out_w = dL.shape

        padded = pad_tensor(inp, self.pad) if self.pad > 0 else inp
        dX = torch.zeros_like(padded)
        for i in range(out_h):
            for j in range(out_w):
                i_s, j_s = i*self.stride, j*self.stride
                dX[:, :, i_s:i_s+self.k_s, j_s:j_s+self.k_s] += dL[:,:,i,j][...,None,None] / (self.k_s ** 2)
        padded.g = dX

    def __repr__(self):
        return f'AvgPool2d(kernel: {self.k_s}, stride: {self.stride}, pad: {self.pad})'