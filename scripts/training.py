# ---------------------------------------------
# | THIS FILE WAS AUTOGENERATED! DO NOT EDIT! |
# ---------------------------------------------
# edit notebooks/training.ipynb and run generate_all.py

import sys
from os.path import join
import math
import matplotlib.pyplot as plt

sys.path.insert(0, '/'.join(sys.path[0].split('/')[:-1] + ['scripts']))
from operations import *
from sequential_model import *

class Dataset():
    def __init__(self, x_data, y_data):
        self.x_data = x_data
        self.y_data = y_data

    def __len__(self):
        return len(self.x_data)

    def __getitem__(self, i):
        return self.x_data[i], self.y_data[i]

class Sampler():
    def __init__(self, size, batch_size, shuffle=True):
        self.size = size
        self.batch_size = batch_size
        self.shuffle = shuffle

    def __iter__(self):
        self.idxs = torch.randperm(self.size) if self.shuffle else torch.arange(self.size)
        for i in range(0, self.size, self.batch_size):
            yield self.idxs[i: i+self.batch_size]

def collate(batch):
    x_batch, y_batch = zip(*batch)
    return torch.stack(x_batch), torch.stack(y_batch)

def compute_accuracy(pre, tar):
    return (torch.argmax(pre, dim=1) == tar).float().mean()

class Optimizer():
    def __init__(self, parameters, learning_rate):
        self.parameters = parameters
        self.learning_rate = learning_rate

    def step(self):
        for parameter in self.parameters:
            parameter.step(self.learning_rate)

    def zero_grad(self):
        for parameter in self.parameters:
            parameter.zero_grad()

def fit(num_epochs, model, optimizer, loss_fn, train_data, valid_data):
    accuracies = []
    losses = []

    for epoch in range(1, num_epochs+1):
        for x_batch, y_batch in train_data:
            pred = model(x_batch)
            loss = loss_fn(pred, y_batch)

            loss_fn.backward()
            model.backward()

            optimizer.step()
            optimizer.zero_grad()

        count = accuracy = loss = 0
        for x_batch, y_batch in valid_data:
            pred = model(x_batch)
            accuracy += compute_accuracy(pred, y_batch)
            loss += loss_fn(pred, y_batch)
            count += 1
        accuracy /= count
        loss /= count

        accuracies.append(accuracy)
        losses.append(loss)
        print(f'Epoch {epoch}    Accuracy {round(accuracy.item(), 3)}    Loss {round(loss.item(), 3)}')

    return accuracies, losses

def plot(data, label):
    plt.plot(list(range(1,len(data)+1)), data)
    plt.xlabel('epoch')
    plt.ylabel(label)
    plt.xticks(list(range(1,len(data)+1)))
    plt.show()