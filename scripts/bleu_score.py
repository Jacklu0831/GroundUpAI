# ---------------------------------------------
# | THIS FILE WAS AUTOGENERATED! DO NOT EDIT! |
# ---------------------------------------------
# edit notebooks/28_bleu_score.ipynb and run generate_all.py

import sys
from os.path import join

sys.path.insert(0, '/'.join(sys.path[0].split('/')[:-1] + ['scripts']))
from gru import *

import numpy as np

class NGram():
    def __init__(self, n_gram, vocab_size=5000):
        '''NGram class for preprocess texts.
            n_gram: gram size
            vocab_size: vocabulary size
        '''
        self.n_gram, self.vocab_size = n_gram, vocab_size

    def __eq__(self, other):
        if len(self.n_gram) != len(other.n_gram): return False
        return np.all(np.array(self.n_gram) == np.array(other.n_gram))

    def __hash__(self):
        return int(sum([self.n_gram[i] * self.vocab_size**i for i, o in enumerate(self.n_gram)]))

    def __repr__(self):
        return f'{self.n_gram}'

def get_grams(inp, n, vocab_size=5000):
    '''Util function for grabbing multiple input NGrams of varying sizes.
        inp: input data
        n: max gram size
        vocab_size: vocabulary size
    '''
    return [NGram(inp[i:i+n], vocab_size) for i in range(len(inp)-n+1)]

def get_correct_n_grams(pre, tar, n, vocab_size=5000):
    '''Compute number of matching n-grams between two sentences.
        pre: predicted sentence
        tar: label sentence
        n: max gram size
        vocab_size: vocabulary size
    '''
    pre_grams = get_grams(pre, n, vocab_size)
    tar_grams = get_grams(tar, n, vocab_size)
    c_pre = Counter(pre_grams)
    c_tar = Counter(tar_grams)
    return sum([min(c_pre[g], c_tar[g]) for g in c_pre]), len(pre_grams)

def bleu(pre, tar, max_grams=4, vocab_size=5000):
    '''Compute BLEU score between two sentences with length penalty.
        pre: predicted sentence
        tar: label sentence
        max_grams: max gram size
        vocab_size: vocabulary size
    '''
    corrects = [get_correct_n_grams(pre, tar, n+1, vocab_size) for n in range(max_grams)]
    precision = reduce(lambda x,y: x*y, [p/l for p,l in corrects])
    len_penalty = exp(1 - len(tar)/len(pre)) if len(pre) < len(tar) else 1
    return len_penalty * precision ** 0.25

def corpus_bleu_score(pres, tars, max_grams=4, vocab_size=5000):
    '''Compute BLEU score between two list of sentences (corpus) with length penalty.
        pres: predicted sentences
        tars: label sentences
        max_grams: max gram size to compare
        vocab_size: vocabulary size
    '''
    pre_len, tar_len = 0, 0
    precisions, lengths = [0] * max_grams, [0] * max_grams
    for pre, tar in zip(pres, tars):
        pre_len += len(pre)
        tar_len += len(tar)
        for n in range(max_grams):
            precision, length = get_correct_n_grams(pre, tar, n+1, vocab_size)
            precisions[n] += precision
            lengths[n] += length
    precision = reduce(lambda x,y: x*y, [p/l for p,l in zip(precisions, lengths)])
    len_penalty = exp(1 - tar_len/pre_len) if pre_len < tar_len else 1
    return len_penalty * precision ** 0.25

class BLEUScore(Callback):
    def __init__(self, max_grams=4, vocab_size=5000):
        '''Callback to compute BLEU score for training NLP models.
            max_grams: max gram size to compare
            vocab_size: vocabulary size
        '''
        self.vocab_size = vocab_size
        self.max_grams = max_grams
        self.bleu_scores = []

    def before_epoch(self, **kwargs):
        self.pre_len, self.tar_len = 0, 0
        self.precisions, self.lengths = [0] * max_grams, [0] * max_grams

    def after_batch(self, pres, tars):
        for pre, tar in zip(pres, tars):
            self.pre_len += len(pre)
            self.tar_len += len(tar)
            for n in range(max_grams):
                precision, length = get_correct_n_grams(pre, tar, n+1, vocab_size)
                self.precisions[n] += precision
                self.lengths[n] += length

    def after_epoch(self):
        precision = reduce(lambda x,y: x*y, [p/l for p,l in zip(self.precisions, self.lengths)])
        len_penalty = exp(1 - tar_len/pre_len) if pre_len < tar_len else 1
        bleu_score = len_penalty * precision ** 0.25
        self.bleu_scores.append(bleu_score)
        print(f'BLEU: {bleu_score}')

    def __repr__(self):
        return f'BLEUScore({self.max_grams})'